@inject IDialogService DialogService
@inject NavigationManager NavigationManager
@inject ICollectionService CollectionService
@inject IRequestService RequestService

@if (Collection != null)
{
    <div>
        <div class="d-flex align-center justify-space-between py-0 px-2 rounded mb-0" 
             Style="@GetCollectionStyle()"
             draggable="true"
             @ondragstart="@(() => HandleDragStart("collection", Collection.Id))"
             @ondragover:preventDefault
             @ondrop="@(() => HandleDrop("collection", Collection.Id))"
             @ondragenter:preventDefault
             @ondragenter="@(() => _isDragOver = true)"
             @ondragleave="@(() => _isDragOver = false)">
            <MudText Style="flex: 1;" Class="d-flex align-center">
                <span @onclick="@(() => ToggleExpanded())" style="cursor: pointer; display: inline-flex; align-items: center;">
                    @if (HasChildren)
                    {
                        <MudIcon Icon="@(_isExpanded ? Icons.Material.Filled.ExpandMore : Icons.Material.Filled.ChevronRight)" Size="Size.Small" />
                    }
                    else
                    {
                        <span style="display: inline-block; width: 1.25rem;"></span>
                    }
                </span>
                <MudIcon Icon="@Icons.Material.Filled.DragIndicator" Size="Size.Small" Class="mr-1" Style="cursor: grab;" Title="Drag to reorder" />
                <span @onclick="@(() => OnSelect.InvokeAsync(Collection))" style="cursor: pointer; display: inline-flex; align-items: center;" class="ml-1">
                    <MudIcon Icon="@Icons.Material.Filled.Folder" Size="Size.Small" Color="@(IsCollectionSelected ? Color.Primary : Color.Default)" Class="mr-1" />
                    <span style="font-size: 0.875rem;">@Collection.Name</span>
                </span>
            </MudText>
            <div style="display: flex; gap: 0.25rem;" @onclick:stopPropagation="true">
                <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Small" OnClick="@(() => ShowAddMenu())" aria-label="Add sub-collection or request" Class="pa-1" />
                <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="@(() => EditCollection())" aria-label="Edit collection" Class="pa-1" />
                <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error" OnClick="@(() => DeleteCollection())" aria-label="Delete collection" Class="pa-1" />
            </div>
        </div>
        
        @if (_isExpanded)
        {
            <div Class="ml-2">
                @if (Collection.Requests != null && Collection.Requests.Any())
                {
                    @foreach (var request in Collection.Requests.OrderBy(r => r.Order))
                    {
                        <div class="d-flex align-center justify-space-between py-0 px-2 rounded mb-0" 
                             Style="@GetRequestStyle(request)"
                             draggable="true"
                             @ondragstart="@(() => HandleDragStart("request", request.Id))"
                             @ondragover:preventDefault
                             @ondrop="@(() => HandleDrop("request", request.Id))"
                             @ondragenter:preventDefault
                             @ondragenter="@(() => _requestDragOver = request.Id)"
                             @ondragleave="@(() => _requestDragOver = null)">
                            <MudIcon Icon="@Icons.Material.Filled.DragIndicator" Size="Size.Small" Class="mr-1" Style="cursor: grab;" Title="Drag to reorder" />
                            <MudText Style="flex: 1; cursor: pointer;" @onclick="@(() => OnRequestSelect.InvokeAsync(request))" Class="d-flex align-center">
                                <MudIcon Icon="@GetRequestIcon(request.Type)" Size="Size.Small" Color="@GetRequestColor(request.Type)" Class="mr-1" />
                                <span style="font-size: 0.875rem;">@request.Name</span>
                            </MudText>
                            <div style="display: flex; gap: 0.25rem;" @onclick:stopPropagation="true">
                                <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="@(() => RenameRequest(request))" aria-label="Rename request" Class="pa-1" />
                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error" OnClick="@(() => DeleteRequest(request))" aria-label="Delete request" Class="pa-1" />
                            </div>
                        </div>
                    }
                }
                
                @if (Collection.SubCollections != null && Collection.SubCollections.Any())
                {
                    @foreach (var subCollection in Collection.SubCollections.OrderBy(c => c.Order))
                    {
                        <DraggableCollectionTreeItem Collection="@subCollection" 
                                          OnSelect="@OnSelect" 
                                          OnRequestSelect="@OnRequestSelect"
                                          OnCollectionUpdated="@OnCollectionUpdated"
                                          OnRequestUpdated="@OnRequestUpdated"
                                          OnReorderNeeded="@OnReorderNeeded"
                                          SelectedCollectionId="@SelectedCollectionId"
                                          SelectedRequestId="@SelectedRequestId" />
                    }
                }
            </div>
        }
    </div>
}

@code {
    [Parameter]
    public Collection? Collection { get; set; }

    [Parameter]
    public EventCallback<Collection> OnSelect { get; set; }

    [Parameter]
    public EventCallback<Request> OnRequestSelect { get; set; }

    [Parameter]
    public EventCallback<(Guid CollectionId, string NewName, bool IsDelete)> OnCollectionUpdated { get; set; }

    [Parameter]
    public EventCallback<(Guid RequestId, string NewName, bool IsDelete)> OnRequestUpdated { get; set; }

    [Parameter]
    public EventCallback OnReorderNeeded { get; set; }

    [Parameter]
    public Guid? SelectedCollectionId { get; set; }

    [Parameter]
    public Guid? SelectedRequestId { get; set; }

    private bool _isExpanded = false;
    private bool _isDragOver = false;
    private Guid? _requestDragOver = null;
    
    // Static fields are required for HTML5 drag-and-drop to work across component instances
    // during a single drag operation. The browser's drag-and-drop API doesn't provide a way
    // to pass data between ondragstart and ondrop events across different component instances,
    // so we must use static state. This is thread-safe for UI operations as Blazor runs on a
    // single UI thread per circuit.
    private static string? _dragType = null;
    private static Guid? _draggedItemId = null;

    // Maximum nesting depth to prevent stack overflow in recursive hierarchy traversal
    private const int MaxRecursionDepth = 50;

    private bool HasChildren => 
        (Collection?.SubCollections != null && Collection.SubCollections.Any()) || 
        (Collection?.Requests != null && Collection.Requests.Any());

    private bool IsCollectionSelected => Collection != null && SelectedCollectionId.HasValue && Collection.Id == SelectedCollectionId.Value;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        
        // Auto-expand if this collection or its descendants contain the selected request
        if (SelectedRequestId.HasValue && ShouldAutoExpand())
        {
            _isExpanded = true;
        }
    }

    private bool ShouldAutoExpand()
    {
        if (Collection == null || !SelectedRequestId.HasValue)
        {
            return false;
        }

        // Check if selected request is directly in this collection
        if (Collection.Requests?.Any(r => r.Id == SelectedRequestId.Value) == true)
        {
            return true;
        }

        // Check if selected request is in any subcollection (recursive)
        return ContainsRequestInSubCollections(Collection, SelectedRequestId.Value);
    }

    private bool ContainsRequestInSubCollections(Collection collection, Guid requestId, int depth = 0)
    {
        // Prevent excessive recursion
        if (depth > MaxRecursionDepth)
        {
            return false;
        }

        if (collection.Requests?.Any(r => r.Id == requestId) == true)
        {
            return true;
        }

        if (collection.SubCollections == null || !collection.SubCollections.Any())
        {
            return false;
        }

        foreach (var subCollection in collection.SubCollections)
        {
            if (ContainsRequestInSubCollections(subCollection, requestId, depth + 1))
            {
                return true;
            }
        }

        return false;
    }

    private void ToggleExpanded()
    {
        if (HasChildren)
        {
            _isExpanded = !_isExpanded;
        }
    }

    private void HandleDragStart(string type, Guid id)
    {
        _dragType = type;
        _draggedItemId = id;
    }

    private async Task HandleDrop(string targetType, Guid targetId)
    {
        _isDragOver = false;
        _requestDragOver = null;

        if (_draggedItemId == null || _dragType == null)
            return;

        if (_dragType == targetType && _draggedItemId == targetId)
            return; // Can't drop on itself

        if (_dragType == "collection" && targetType == "collection")
        {
            await ReorderCollections(_draggedItemId.Value, targetId);
        }
        else if (_dragType == "request" && targetType == "request")
        {
            await ReorderRequests(_draggedItemId.Value, targetId);
        }

        _dragType = null;
        _draggedItemId = null;

        await OnReorderNeeded.InvokeAsync();
    }

    private async Task ReorderCollections(Guid draggedId, Guid targetId)
    {
        // This method is only called for subcollections within the tree.
        // Root-level collections are handled by CollectionView component.
        if (Collection?.ParentCollectionId == null)
            return;

        var parentCollection = await CollectionService.GetCollectionByIdAsync(Collection.ParentCollectionId.Value);
        if (parentCollection == null)
            return;

        var siblings = parentCollection.SubCollections.OrderBy(c => c.Order).ToList();
        var draggedIndex = siblings.FindIndex(c => c.Id == draggedId);
        var targetIndex = siblings.FindIndex(c => c.Id == targetId);

        if (draggedIndex == -1 || targetIndex == -1)
            return;

        // Reorder the list
        var draggedItem = siblings[draggedIndex];
        siblings.RemoveAt(draggedIndex);
        siblings.Insert(targetIndex, draggedItem);

        // Update order values and save
        var orderedIds = siblings.Select(c => c.Id);
        await CollectionService.ReorderCollectionsAsync(orderedIds);
    }

    private async Task ReorderRequests(Guid draggedId, Guid targetId)
    {
        if (Collection == null)
            return;

        var requests = Collection.Requests.OrderBy(r => r.Order).ToList();
        var draggedIndex = requests.FindIndex(r => r.Id == draggedId);
        var targetIndex = requests.FindIndex(r => r.Id == targetId);

        if (draggedIndex == -1 || targetIndex == -1)
            return;

        // Reorder the list
        var draggedItem = requests[draggedIndex];
        requests.RemoveAt(draggedIndex);
        requests.Insert(targetIndex, draggedItem);

        // Update order values and save
        var orderedIds = requests.Select(r => r.Id);
        await RequestService.ReorderRequestsAsync(orderedIds);
    }

    private string GetCollectionStyle()
    {
        var baseStyle = "";
        if (_isDragOver)
        {
            baseStyle += " background-color: rgba(var(--mud-palette-primary-rgb), 0.08); border: 2px dashed var(--mud-palette-primary);";
        }
        else if (IsCollectionSelected)
        {
            baseStyle += " background-color: rgba(var(--mud-palette-primary-rgb), 0.12); border-left: 3px solid var(--mud-palette-primary);";
        }
        else
        {
            baseStyle += " border-left: 3px solid transparent;";
        }
        return baseStyle;
    }

    private string GetRequestStyle(Request request)
    {
        var baseStyle = "";
        if (_requestDragOver == request.Id)
        {
            baseStyle += " background-color: rgba(var(--mud-palette-primary-rgb), 0.08); border: 2px dashed var(--mud-palette-primary);";
        }
        else if (SelectedRequestId.HasValue && request.Id == SelectedRequestId.Value)
        {
            baseStyle += " background-color: rgba(var(--mud-palette-primary-rgb), 0.12); border-left: 3px solid var(--mud-palette-primary);";
        }
        else
        {
            baseStyle += " border-left: 3px solid transparent;";
        }
        return baseStyle;
    }

    private string GetRequestIcon(RequestType type) => type switch
    {
        RequestType.Rest => Icons.Material.Filled.Http,
        RequestType.GraphQL => Icons.Material.Filled.GraphicEq,
        RequestType.WebSocket => Icons.Material.Filled.Cable,
        _ => Icons.Material.Filled.Article
    };

    private Color GetRequestColor(RequestType type) => type switch
    {
        RequestType.Rest => Color.Primary,
        RequestType.GraphQL => Color.Secondary,
        RequestType.WebSocket => Color.Tertiary,
        _ => Color.Default
    };

    private async Task ShowAddMenu()
    {
        if (Collection == null) return;

        var options = new List<string> { "New Sub-Collection", "New Request" };
        var parameters = new DialogParameters
        {
            ["Options"] = options
        };

        var dialog = await DialogService.ShowAsync<SelectOptionDialog>("Add", parameters);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is string selectedOption)
        {
            if (selectedOption == "New Sub-Collection")
            {
                CreateSubCollection();
            }
            else if (selectedOption == "New Request")
            {
                CreateRequest();
            }
        }
    }

    private void CreateSubCollection()
    {
        if (Collection == null) return;
        NavigationManager.NavigateTo($"/collection/{Collection.Id}/subcollection/create");
    }

    private void CreateRequest()
    {
        if (Collection == null) return;
        NavigationManager.NavigateTo($"/collection/{Collection.Id}/request/create");
    }

    private void EditCollection()
    {
        if (Collection == null) return;
        
        // Preserve the selected request when navigating to edit
        var url = $"/collection/{Collection.Id}/edit";
        if (SelectedRequestId.HasValue)
        {
            url += $"?requestId={SelectedRequestId.Value}";
        }
        NavigationManager.NavigateTo(url);
    }

    private async Task DeleteCollection()
    {
        if (Collection == null) return;

        var parameters = new DialogParameters
        {
            ["ContentText"] = $"Are you sure you want to delete the collection '{Collection.Name}'? This action cannot be undone.",
            ["ButtonText"] = "Delete",
            ["Color"] = Color.Error
        };

        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Delete Collection", parameters);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await OnCollectionUpdated.InvokeAsync((Collection.Id, string.Empty, true));
        }
    }

    private async Task RenameRequest(Request request)
    {
        var parameters = new DialogParameters
        {
            ["CurrentName"] = request.Name
        };

        var dialog = await DialogService.ShowAsync<RenameDialog>("Rename Request", parameters);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is string newName && !string.IsNullOrWhiteSpace(newName))
        {
            await OnRequestUpdated.InvokeAsync((request.Id, newName, false));
        }
    }

    private async Task DeleteRequest(Request request)
    {
        var parameters = new DialogParameters
        {
            ["ContentText"] = $"Are you sure you want to delete the request '{request.Name}'? This action cannot be undone.",
            ["ButtonText"] = "Delete",
            ["Color"] = Color.Error
        };

        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Delete Request", parameters);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await OnRequestUpdated.InvokeAsync((request.Id, string.Empty, true));
        }
    }
}
