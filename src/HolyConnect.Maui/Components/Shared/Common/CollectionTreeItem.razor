@inject IDialogService DialogService
@inject NavigationManager NavigationManager

@if (Collection != null)
{
    <div>
        <MudPaper Class="pa-2 mb-1" Style="@GetCollectionStyle()">
            <MudText Style="flex: 1;">
                <span @onclick="@(() => ToggleExpanded())" style="cursor: pointer;">
                    @if (HasChildren)
                    {
                        <MudIcon Icon="@(_isExpanded ? Icons.Material.Filled.ExpandMore : Icons.Material.Filled.ChevronRight)" Size="Size.Small" />
                    }
                    else
                    {
                        <span style="display: inline-block; width: 1.5rem;"></span>
                    }
                </span>
                <span @onclick="@(() => OnSelect.InvokeAsync(Collection))" style="cursor: pointer;">
                    <MudIcon Icon="@Icons.Material.Filled.Folder" Size="Size.Small" Color="@(IsCollectionSelected ? Color.Primary : Color.Default)" /> @Collection.Name
                </span>
            </MudText>
            <div style="display: flex; gap: 0.25rem;" @onclick:stopPropagation="true">
                <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Small" OnClick="@(() => ShowAddMenu())" aria-label="Add sub-collection or request" />
                <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="@(() => EditCollection())" aria-label="Edit collection" />
                <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error" OnClick="@(() => DeleteCollection())" aria-label="Delete collection" />
            </div>
        </MudPaper>
        
        @if (_isExpanded)
        {
            <div Class="ml-4">
                @if (Collection.Requests != null && Collection.Requests.Any())
                {
                    @foreach (var request in Collection.Requests)
                    {
                        <MudPaper Class="pa-2 mb-1" Style="@GetRequestStyle(request)">
                            <MudText Style="flex: 1; cursor: pointer;" @onclick="@(() => OnRequestSelect.InvokeAsync(request))">
                                <MudIcon Icon="@GetRequestIcon(request.Type)" Size="Size.Small" Color="@GetRequestColor(request.Type)" /> @request.Name
                            </MudText>
                            <div style="display: flex; gap: 0.25rem;" @onclick:stopPropagation="true">
                                <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="@(() => RenameRequest(request))" aria-label="Rename request" />
                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error" OnClick="@(() => DeleteRequest(request))" aria-label="Delete request" />
                            </div>
                        </MudPaper>
                    }
                }
                
                @if (Collection.SubCollections != null && Collection.SubCollections.Any())
                {
                    @foreach (var subCollection in Collection.SubCollections)
                    {
                        <CollectionTreeItem Collection="@subCollection" 
                                          OnSelect="@OnSelect" 
                                          OnRequestSelect="@OnRequestSelect"
                                          OnCollectionUpdated="@OnCollectionUpdated"
                                          OnRequestUpdated="@OnRequestUpdated"
                                          SelectedCollectionId="@SelectedCollectionId"
                                          SelectedRequestId="@SelectedRequestId" />
                    }
                }
            </div>
        }
    </div>
}

@code {
    [Parameter]
    public Collection? Collection { get; set; }

    [Parameter]
    public EventCallback<Collection> OnSelect { get; set; }

    [Parameter]
    public EventCallback<Request> OnRequestSelect { get; set; }

    [Parameter]
    public EventCallback<(Guid CollectionId, string NewName, bool IsDelete)> OnCollectionUpdated { get; set; }

    [Parameter]
    public EventCallback<(Guid RequestId, string NewName, bool IsDelete)> OnRequestUpdated { get; set; }

    [Parameter]
    public Guid? SelectedCollectionId { get; set; }

    [Parameter]
    public Guid? SelectedRequestId { get; set; }

    private bool _isExpanded = false;

    private bool HasChildren => 
        (Collection?.SubCollections != null && Collection.SubCollections.Any()) || 
        (Collection?.Requests != null && Collection.Requests.Any());

    private bool IsCollectionSelected => Collection != null && SelectedCollectionId.HasValue && Collection.Id == SelectedCollectionId.Value;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        
        // Auto-expand if this collection or its descendants contain the selected request
        if (SelectedRequestId.HasValue && ShouldAutoExpand())
        {
            _isExpanded = true;
        }
    }

    private bool ShouldAutoExpand()
    {
        if (Collection == null || !SelectedRequestId.HasValue)
        {
            return false;
        }

        // Check if selected request is directly in this collection
        if (Collection.Requests?.Any(r => r.Id == SelectedRequestId.Value) == true)
        {
            return true;
        }

        // Check if selected request is in any subcollection (recursive)
        return ContainsRequestInSubCollections(Collection, SelectedRequestId.Value);
    }

    private bool ContainsRequestInSubCollections(Collection collection, Guid requestId, int depth = 0)
    {
        // Prevent excessive recursion (max 50 levels should be more than enough)
        if (depth > 50)
        {
            return false;
        }

        if (collection.Requests?.Any(r => r.Id == requestId) == true)
        {
            return true;
        }

        if (collection.SubCollections == null || !collection.SubCollections.Any())
        {
            return false;
        }

        foreach (var subCollection in collection.SubCollections)
        {
            if (ContainsRequestInSubCollections(subCollection, requestId, depth + 1))
            {
                return true;
            }
        }

        return false;
    }

    private void ToggleExpanded()
    {
        if (HasChildren)
        {
            _isExpanded = !_isExpanded;
        }
    }

    private string GetCollectionStyle()
    {
        var baseStyle = "display: flex; align-items: center; justify-content: space-between;";
        if (IsCollectionSelected)
        {
            return baseStyle + " background-color: rgba(var(--mud-palette-primary-rgb), 0.12); border-left: 3px solid var(--mud-palette-primary);";
        }
        return baseStyle;
    }

    private string GetRequestStyle(Request request)
    {
        var baseStyle = "display: flex; align-items: center; justify-content: space-between;";
        if (SelectedRequestId.HasValue && request.Id == SelectedRequestId.Value)
        {
            return baseStyle + " background-color: rgba(var(--mud-palette-primary-rgb), 0.12); border-left: 3px solid var(--mud-palette-primary);";
        }
        return baseStyle;
    }

    private string GetRequestIcon(RequestType type) => type switch
    {
        RequestType.Rest => Icons.Material.Filled.Http,
        RequestType.GraphQL => Icons.Material.Filled.GraphicEq,
        _ => Icons.Material.Filled.Article
    };

    private Color GetRequestColor(RequestType type) => type switch
    {
        RequestType.Rest => Color.Primary,
        RequestType.GraphQL => Color.Secondary,
        _ => Color.Default
    };

    private async Task ShowAddMenu()
    {
        if (Collection == null) return;

        var options = new List<string> { "New Sub-Collection", "New Request" };
        var parameters = new DialogParameters
        {
            ["Options"] = options
        };

        var dialog = await DialogService.ShowAsync<SelectOptionDialog>("Add", parameters);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is string selectedOption)
        {
            if (selectedOption == "New Sub-Collection")
            {
                CreateSubCollection();
            }
            else if (selectedOption == "New Request")
            {
                CreateRequest();
            }
        }
    }

    private void CreateSubCollection()
    {
        if (Collection == null) return;
        NavigationManager.NavigateTo($"/collection/{Collection.Id}/subcollection/create");
    }

    private void CreateRequest()
    {
        if (Collection == null) return;
        NavigationManager.NavigateTo($"/collection/{Collection.Id}/request/create");
    }

    private void EditCollection()
    {
        if (Collection == null) return;
        
        // Preserve the selected request when navigating to edit
        var url = $"/collection/{Collection.Id}/edit";
        if (SelectedRequestId.HasValue)
        {
            url += $"?requestId={SelectedRequestId.Value}";
        }
        NavigationManager.NavigateTo(url);
    }

    private async Task DeleteCollection()
    {
        if (Collection == null) return;

        var parameters = new DialogParameters
        {
            ["ContentText"] = $"Are you sure you want to delete the collection '{Collection.Name}'? This action cannot be undone.",
            ["ButtonText"] = "Delete",
            ["Color"] = Color.Error
        };

        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Delete Collection", parameters);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await OnCollectionUpdated.InvokeAsync((Collection.Id, string.Empty, true));
        }
    }

    private async Task RenameRequest(Request request)
    {
        var parameters = new DialogParameters
        {
            ["CurrentName"] = request.Name
        };

        var dialog = await DialogService.ShowAsync<RenameDialog>("Rename Request", parameters);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is string newName && !string.IsNullOrWhiteSpace(newName))
        {
            await OnRequestUpdated.InvokeAsync((request.Id, newName, false));
        }
    }

    private async Task DeleteRequest(Request request)
    {
        var parameters = new DialogParameters
        {
            ["ContentText"] = $"Are you sure you want to delete the request '{request.Name}'? This action cannot be undone.",
            ["ButtonText"] = "Delete",
            ["Color"] = Color.Error
        };

        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Delete Request", parameters);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await OnRequestUpdated.InvokeAsync((request.Id, string.Empty, true));
        }
    }
}
