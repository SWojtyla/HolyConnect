@using HolyConnect.Domain.Entities
@inject IJSRuntime JSRuntime
@inject IGraphQLSchemaService SchemaService
@inject IDialogService DialogService
@inject SettingsService SettingsService
@inject IVariableResolver VariableResolver
@implements IAsyncDisposable

<MudPaper Elevation="2" Class="pa-0" Style="@(string.IsNullOrEmpty(Height) ? "height: 25rem;" : $"height: {Height};")">
    <div style="display: flex; flex-direction: column; height: 100%;">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="px-3 py-2" Style="border-bottom: 1px solid var(--mud-palette-divider);">
            <MudText Typo="Typo.subtitle2" Color="Color.Default">GraphQL Query Editor</MudText>
            <MudTooltip Text="View GraphQL Schema">
                <MudIconButton Icon="@Icons.Material.Filled.Schema" 
                              Size="Size.Small" 
                              Color="Color.Primary" 
                              OnClick="OpenSchemaViewer"
                              Disabled="@(Request == null || string.IsNullOrWhiteSpace(Request.Url))" />
            </MudTooltip>
        </MudStack>
        <div id="@_editorId" style="flex: 1; overflow: hidden;"></div>
    </div>
</MudPaper>

@code {
    [Parameter]
    public string? Value { get; set; }

    [Parameter]
    public EventCallback<string?> ValueChanged { get; set; }

    [Parameter]
    public string? Height { get; set; }

    [Parameter]
    public GraphQLRequest? Request { get; set; }

    [Parameter]
    public bool ReadOnly { get; set; }

    [Parameter]
    public string? Theme { get; set; }

    [Parameter]
    public Domain.Entities.Environment? Environment { get; set; }

    [Parameter]
    public Collection? Collection { get; set; }

    private string _editorId = $"monaco-editor-{Guid.NewGuid()}";
    private DotNetObjectReference<GraphQLCodeEditor>? _dotNetHelper;
    private bool _isInitialized;
    private string? _lastUrl;
    private string _currentTheme = "vs-dark";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _dotNetHelper = DotNetObjectReference.Create(this);
                
                // Determine theme based on app settings
                await DetermineThemeAsync();
                
                // Initialize Monaco Editor
                var success = await JSRuntime.InvokeAsync<bool>(
                    "monacoEditorInterop.initializeEditor",
                    _editorId,
                    Value ?? string.Empty,
                    "graphql",
                    _currentTheme,
                    ReadOnly
                );

                if (success)
                {
                    _isInitialized = true;

                    // Register value change callback
                    await JSRuntime.InvokeVoidAsync(
                        "monacoEditorInterop.onValueChanged",
                        _editorId,
                        _dotNetHelper
                    );

                    // Register variable hover provider if environment is available
                    if (Environment != null)
                    {
                        await JSRuntime.InvokeVoidAsync(
                            "monacoEditorInterop.registerVariableHoverProvider",
                            _editorId,
                            _dotNetHelper
                        );
                    }

                    // Load schema if URL is available
                    if (Request != null && !string.IsNullOrWhiteSpace(Request.Url))
                    {
                        await LoadSchemaAsync();
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing Monaco Editor: {ex.Message}");
            }
        }
    }
    
    private async Task DetermineThemeAsync()
    {
        if (!string.IsNullOrEmpty(Theme))
        {
            _currentTheme = Theme;
            return;
        }
        
        try
        {
            var settings = await SettingsService.GetSettingsAsync();
            _currentTheme = settings.IsDarkMode ? "vs-dark" : "vs";
        }
        catch
        {
            _currentTheme = "vs-dark"; // Default fallback
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_isInitialized)
        {
            // Update value if changed externally
            var currentValue = await JSRuntime.InvokeAsync<string?>("monacoEditorInterop.getValue", _editorId);
            if (currentValue != Value)
            {
                await JSRuntime.InvokeVoidAsync("monacoEditorInterop.setValue", _editorId, Value ?? string.Empty);
            }

            // Re-register hover provider if environment is available
            if (Environment != null && _dotNetHelper != null)
            {
                await JSRuntime.InvokeVoidAsync(
                    "monacoEditorInterop.registerVariableHoverProvider",
                    _editorId,
                    _dotNetHelper
                );
            }

            // Reload schema if URL changed
            if (Request != null && Request.Url != _lastUrl)
            {
                _lastUrl = Request.Url;
                await LoadSchemaAsync();
            }
        }
    }

    [JSInvokable]
    public async Task OnValueChanged(string value)
    {
        Value = value;
        await ValueChanged.InvokeAsync(value);
    }

    [JSInvokable]
    public Task<string?> GetVariableHoverInfo(string variableName)
    {
        if (Environment == null || string.IsNullOrEmpty(variableName))
        {
            return Task.FromResult<string?>(null);
        }

        var value = VariableResolver.GetVariableValue(variableName, Environment, Collection);
        
        if (value != null)
        {
            var source = Collection?.Variables.ContainsKey(variableName) == true ? "Collection" : "Environment";
            return Task.FromResult<string?>($"`{variableName}` = **{value}** _(from {source})_");
        }
        else
        {
            return Task.FromResult<string?>($"`{variableName}` = **MISSING**");
        }
    }

    private async Task LoadSchemaAsync()
    {
        if (Request == null || string.IsNullOrWhiteSpace(Request.Url))
        {
            return;
        }

        try
        {
            var schemaJson = await SchemaService.FetchSchemaAsync(Request.Url, Request);
            
            if (!string.IsNullOrEmpty(schemaJson))
            {
                await JSRuntime.InvokeVoidAsync(
                    "monacoEditorInterop.registerGraphQLCompletionProvider",
                    _editorId,
                    schemaJson
                );
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading GraphQL schema: {ex.Message}");
        }
    }

    public async Task TriggerSuggestionsAsync()
    {
        if (_isInitialized)
        {
            await JSRuntime.InvokeVoidAsync("monacoEditorInterop.triggerSuggest", _editorId);
        }
    }

    public async Task FormatDocumentAsync()
    {
        if (_isInitialized)
        {
            await JSRuntime.InvokeVoidAsync("monacoEditorInterop.formatDocument", _editorId);
        }
    }

    private async Task OpenSchemaViewer()
    {
        if (Request == null || string.IsNullOrWhiteSpace(Request.Url))
        {
            return;
        }
        
        var parameters = new DialogParameters<GraphQLSchemaViewer>
        {
            { x => x.Request, Request }
        };
        
        var options = new DialogOptions 
        { 
            MaxWidth = MaxWidth.Large, 
            FullWidth = true,
            CloseButton = true
        };
        
        await DialogService.ShowAsync<GraphQLSchemaViewer>("GraphQL Schema", parameters, options);
    }

    public async ValueTask DisposeAsync()
    {
        if (_isInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("monacoEditorInterop.disposeEditor", _editorId);
            }
            catch
            {
                // Ignore disposal errors
            }
        }

        _dotNetHelper?.Dispose();
    }
}
