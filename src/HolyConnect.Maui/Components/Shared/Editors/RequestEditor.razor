@inject IRequestService RequestService
@inject IFormatterService FormatterService
@inject ISnackbar Snackbar
@inject SettingsService SettingsService
@implements IDisposable

@if (_layout == Domain.Entities.RequestLayout.Vertical)
{
    <!-- Vertical Layout: Request on left, Response on right (side-by-side split with MudSplitter) -->
    <MudSplitter @bind-Dimension="@_splitPercentage"
                 EnableSlide="true"
                 EnableMargin="true"
                 Sensitivity="0.1"
                 Height="calc(100vh - 11.25rem)"
                 Bordered="true">
        <StartContent>
            <div style="height: 100%; width: 100%; display: flex; flex-direction: column; overflow: hidden; padding-right: 0.5rem;">
                @RequestConfigurationSection
            </div>
        </StartContent>
        <EndContent>
            <div style="height: 100%; width: 100%; display: flex; flex-direction: column; overflow: hidden; padding-left: 0.5rem;">
                @ResponseSection
            </div>
        </EndContent>
    </MudSplitter>
}
else
{
    <!-- Horizontal Layout: Request on top, Response on bottom -->
    <div Style="height: calc(100vh - 11.25rem); display: flex; flex-direction: column; overflow: hidden;">
        <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
            @RequestConfigurationSection
        </div>
        
        <MudDivider Class="my-4" />
        <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0;">
            @ResponseSection
        </div>
    </div>
}

@code {
    private RenderFragment RequestConfigurationSection => __builder =>
    {
<MudCard Style="height: 100%; display: flex; flex-direction: column;">
    <MudCardContent Style="flex: 1; display: flex; flex-direction: column; overflow: hidden; padding-bottom: 0;">      
        
        @if (Request is RestRequest restRequest)
        {
            <RestRequestEditor Request="@restRequest" Environment="@Environment" Collection="@Collection" />
        }
        else if (Request is GraphQLRequest graphQLRequest)
        {
            <GraphQLRequestEditor Request="@graphQLRequest" Environment="@Environment" Collection="@Collection" />
        }
        else if (Request is WebSocketRequest webSocketRequest)
        {
            <WebSocketRequestEditor Request="@webSocketRequest" Environment="@Environment" Collection="@Collection" />
        }

    </MudCardContent>
    <MudCardActions>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
            <MudButton Variant="Variant.Filled" 
                       Color="Color.Primary" 
                       OnClick="ExecuteRequest" 
                       StartIcon="@Icons.Material.Filled.Send"
                       Disabled="_isExecuting">
                @if (_isExecuting)
                {
                    <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                    <span>Sending...</span>
                }
                else
                {
                    <span>Send</span>
                }
            </MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Secondary" OnClick="SaveRequestInternal" Disabled="_isExecuting">
                Save
            </MudButton>
            <MudMenu Icon="@Icons.Material.Filled.SwapHoriz" 
                     Variant="Variant.Outlined" 
                     Label="Convert To" 
                     Size="Size.Medium"
                     Disabled="_isExecuting">
                @if (Request?.Type != RequestType.Rest)
                {
                    <MudMenuItem OnClick="@(() => ConvertRequestTo(RequestType.Rest))">REST</MudMenuItem>
                }
                @if (Request?.Type != RequestType.GraphQL)
                {
                    <MudMenuItem OnClick="@(() => ConvertRequestTo(RequestType.GraphQL))">GraphQL</MudMenuItem>
                }
                @if (Request?.Type != RequestType.WebSocket)
                {
                    <MudMenuItem OnClick="@(() => ConvertRequestTo(RequestType.WebSocket))">WebSocket</MudMenuItem>
                }
            </MudMenu>
            <MudButton Variant="Variant.Outlined" Color="Color.Default" OnClick="@(() => OnCancel.InvokeAsync())" Disabled="_isExecuting">
                Cancel
            </MudButton>
        </MudStack>
    </MudCardActions>
</MudCard>
    };

    private RenderFragment ResponseSection => __builder =>
    {
        <ResponseViewer Response="@_response" />
    };
}

@code {
    [Parameter]
    public Request? Request { get; set; }

    [Parameter]
    public EventCallback OnSave { get; set; }

    [Parameter]
    public EventCallback OnCancel { get; set; }

    [Parameter]
    public Domain.Entities.Environment? Environment { get; set; }

    [Parameter]
    public Collection? Collection { get; set; }

    private RequestResponse? _response;
    private Domain.Entities.RequestLayout _layout = Domain.Entities.RequestLayout.Horizontal;
    private bool _isExecuting;
    private double _splitPercentage = 50;

    protected override async Task OnInitializedAsync()
    {
        var settings = await SettingsService.GetSettingsAsync();
        _layout = settings.Layout;
    }

    private async Task ExecuteRequest()
    {
        if (Request == null) return;

        _isExecuting = true;
        StateHasChanged();

        try
        {
            // Note: Headers/Params are now synced directly in the child components
            _response = await RequestService.ExecuteRequestAsync(Request);          
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error executing request: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isExecuting = false;
            StateHasChanged();
        }
    }

    private async Task SaveRequestInternal()
    {
        if (Request == null) return;
        await OnSave.InvokeAsync();
    }

    private async Task ConvertRequestTo(RequestType targetType)
    {
        if (Request == null) return;

        try
        {
            // Store the original request ID and references
            var originalId = Request.Id;
            var originalCollectionId = Request.CollectionId;

            // Delete the original request
            await RequestService.DeleteRequestAsync(originalId);

            // Convert to new type
            var convertedRequest = Application.Common.RequestConverter.ConvertTo(Request, targetType);
            
            // Use the original ID to replace the request
            convertedRequest.Id = originalId;
            convertedRequest.CollectionId = originalCollectionId;
            
            // Remove the "(TypeName)" suffix from the name that ConvertTo adds
            convertedRequest.Name = Request.Name;
            
            // Create the converted request (effectively replacing the original)
            var createdRequest = await RequestService.CreateRequestAsync(convertedRequest);
            
            Snackbar.Add($"Request converted to {targetType} successfully", Severity.Success);
            
            // Update the local Request reference to the converted request
            Request = createdRequest;
            
            // Notify parent component to refresh
            await OnSave.InvokeAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error converting request: {ex.Message}", Severity.Error);
        }
    }

    public void Dispose()
    {
        // Auto-save when navigating away from the editor if the setting is enabled
        if (Request != null)
        {
            Task.Run(async () =>
            {
                try
                {
                    var settings = await SettingsService.GetSettingsAsync();
                    if (settings.AutoSaveOnNavigate)
                    {
                        await OnSave.InvokeAsync();
                    }
                }
                catch
                {
                    // Silently ignore errors during auto-save on dispose
                    // The component is being destroyed, so we can't show errors to the user
                }
            });
        }
    }
}
