@page "/git"
@inject IGitService GitService
@inject SettingsService SettingsService
@inject ISnackbar Snackbar
@using HolyConnect.Application.Interfaces
@using LibGit2Sharp

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4 mb-6">
    <MudOverlay Visible="_isLoading" DarkBackground="true" Absolute="false">
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
    </MudOverlay>
    <MudText Typo="Typo.h4" Class="mb-4">Git Management</MudText>

    @if (!_isRepository)
    {
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">Git Not Initialized</MudText>
                <MudText Typo="Typo.body2" Class="mb-3">
                    The storage path is not a git repository. Initialize git to enable version control for your collections.
                </MudText>
                <MudButton Variant="Variant.Filled" 
                          Color="Color.Primary" 
                          OnClick="InitializeRepository"
                          StartIcon="@Icons.Material.Filled.AddCircle">
                    Initialize Git Repository
                </MudButton>
            </MudCardContent>
        </MudCard>
    }
    else
    {
        <!-- Repository Status -->
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-3">
                    <MudText Typo="Typo.h6">Repository Status</MudText>
                    <MudButton Variant="Variant.Outlined" 
                              Color="Color.Info" 
                              OnClick="RefreshStatus"
                              StartIcon="@Icons.Material.Filled.Refresh"
                              Size="Size.Small"
                              Disabled="_isLoading">
                        Refresh
                    </MudButton>
                </MudStack>
                
                <MudGrid>
                    <MudItem xs="12" sm="6" md="3">
                        <MudPaper Class="pa-3" Outlined="true">
                            <MudStack Spacing="1">
                                <MudIcon Icon="@Icons.Material.Filled.Source" Color="Color.Info" />
                                <MudText Typo="Typo.caption">Current Branch</MudText>
                                <MudText Typo="Typo.body1">
                                    <strong>@(_currentBranch ?? "Unknown")</strong>
                                </MudText>
                            </MudStack>
                        </MudPaper>
                    </MudItem>
                    <MudItem xs="12" sm="6" md="3">
                        <MudPaper Class="pa-3" Outlined="true">
                            <MudStack Spacing="1">
                                <MudIcon Icon="@Icons.Material.Filled.Edit" Color="@(_status?.ModifiedFiles > 0 ? Color.Warning : Color.Default)" />
                                <MudText Typo="Typo.caption">Modified</MudText>
                                <MudText Typo="Typo.body1">
                                    <strong>@(_status?.ModifiedFiles ?? 0) files</strong>
                                </MudText>
                            </MudStack>
                        </MudPaper>
                    </MudItem>
                    <MudItem xs="12" sm="6" md="3">
                        <MudPaper Class="pa-3" Outlined="true">
                            <MudStack Spacing="1">
                                <MudIcon Icon="@Icons.Material.Filled.CloudDownload" Color="@(_incomingCommits.Any() ? Color.Info : Color.Default)" />
                                <MudText Typo="Typo.caption">Incoming</MudText>
                                <MudText Typo="Typo.body1">
                                    <strong>@_incomingCommits.Count() commits</strong>
                                </MudText>
                            </MudStack>
                        </MudPaper>
                    </MudItem>
                    <MudItem xs="12" sm="6" md="3">
                        <MudPaper Class="pa-3" Outlined="true">
                            <MudStack Spacing="1">
                                <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Color="@(_outgoingCommits.Any() ? Color.Warning : Color.Default)" />
                                <MudText Typo="Typo.caption">Outgoing</MudText>
                                <MudText Typo="Typo.body1">
                                    <strong>@_outgoingCommits.Count() commits</strong>
                                </MudText>
                            </MudStack>
                        </MudPaper>
                    </MudItem>
                </MudGrid>

                @if (_incomingCommits.Any() || _outgoingCommits.Any())
                {
                    <MudGrid Class="mt-3">
                        @if (_incomingCommits.Any())
                        {
                            <MudItem xs="12" md="6">
                                <MudText Typo="Typo.subtitle2" Class="mb-2">Incoming Commits:</MudText>
                                <MudList T="string" Dense="true" Class="ml-2">
                                    @foreach (var commit in _incomingCommits.Take(5))
                                    {
                                        <MudListItem T="string">
                                            <MudText Typo="Typo.body2">
                                                <strong>@commit.ShortSha</strong> - @commit.Message
                                                <br />
                                                <span style="font-size: 0.8em; color: gray;">@commit.Author - @commit.Date.ToString("yyyy-MM-dd HH:mm")</span>
                                            </MudText>
                                        </MudListItem>
                                    }
                                    @if (_incomingCommits.Count() > 5)
                                    {
                                        <MudListItem T="string">
                                            <MudText Typo="Typo.caption">... and @(_incomingCommits.Count() - 5) more</MudText>
                                        </MudListItem>
                                    }
                                </MudList>
                            </MudItem>
                        }
                        @if (_outgoingCommits.Any())
                        {
                            <MudItem xs="12" md="6">
                                <MudText Typo="Typo.subtitle2" Class="mb-2">Outgoing Commits:</MudText>
                                <MudList T="string" Dense="true" Class="ml-2">
                                    @foreach (var commit in _outgoingCommits.Take(5))
                                    {
                                        <MudListItem T="string">
                                            <MudText Typo="Typo.body2">
                                                <strong>@commit.ShortSha</strong> - @commit.Message
                                                <br />
                                                <span style="font-size: 0.8em; color: gray;">@commit.Author - @commit.Date.ToString("yyyy-MM-dd HH:mm")</span>
                                            </MudText>
                                        </MudListItem>
                                    }
                                    @if (_outgoingCommits.Count() > 5)
                                    {
                                        <MudListItem T="string">
                                            <MudText Typo="Typo.caption">... and @(_outgoingCommits.Count() - 5) more</MudText>
                                        </MudListItem>
                                    }
                                </MudList>
                            </MudItem>
                        }
                    </MudGrid>
                }

                @if (_status?.HasChanges == true)
                {
                    <MudText Typo="Typo.subtitle2" Class="mt-3 mb-2">Changes:</MudText>
                    <MudList T="string" Dense="true" Class="ml-2">
                        @foreach (var change in _status.Changes.Take(10))
                        {
                            <MudListItem T="string">
                                <MudText Typo="Typo.body2">@change</MudText>
                            </MudListItem>
                        }
                        @if (_status.Changes.Count > 10)
                        {
                            <MudListItem T="string">
                                <MudText Typo="Typo.caption">... and @(_status.Changes.Count - 10) more</MudText>
                            </MudListItem>
                        }
                    </MudList>
                }

            </MudCardContent>
        </MudCard>

        <!-- Branch Operations -->
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">Branch Operations</MudText>
                
                <MudText Typo="Typo.subtitle2" Class="mb-2">Switch Branch:</MudText>
                <MudGrid>
                    <MudItem xs="12" sm="8">
                        <MudSelect @bind-Value="_selectedBranch" 
                                  Label="Select Branch" 
                                  Variant="Variant.Outlined"
                                  T="string">
                            @foreach (var branch in _branches)
                            {
                                <MudSelectItem Value="@branch">@branch</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>
                    <MudItem xs="12" sm="4">
                        <MudButton Variant="Variant.Filled" 
                                  Color="Color.Primary" 
                                  OnClick="SwitchBranch"
                                  Disabled="@(string.IsNullOrEmpty(_selectedBranch) || _selectedBranch == _currentBranch)"
                                  FullWidth="true"
                                  StartIcon="@Icons.Material.Filled.Sync">
                            Switch
                        </MudButton>
                    </MudItem>
                </MudGrid>

                <MudDivider Class="my-3" />

                <MudText Typo="Typo.subtitle2" Class="mb-2">Create New Branch:</MudText>
                <MudGrid>
                    <MudItem xs="12" sm="8">
                        <MudTextField @bind-Value="_newBranchName" 
                                     Label="Branch Name" 
                                     Variant="Variant.Outlined" />
                    </MudItem>
                    <MudItem xs="12" sm="4">
                        <MudButton Variant="Variant.Filled" 
                                  Color="Color.Success" 
                                  OnClick="CreateBranch"
                                  Disabled="@string.IsNullOrWhiteSpace(_newBranchName)"
                                  FullWidth="true"
                                  StartIcon="@Icons.Material.Filled.Add">
                            Create
                        </MudButton>
                    </MudItem>
                </MudGrid>

                <MudDivider Class="my-3" />

                <MudText Typo="Typo.subtitle2" Class="mb-2">Delete Branch:</MudText>
                <MudGrid>
                    <MudItem xs="12" sm="8">
                        <MudSelect @bind-Value="_branchToDelete" 
                                  Label="Select Branch to Delete" 
                                  Variant="Variant.Outlined"
                                  T="string">
                            @foreach (var branch in _branches.Where(b => b != _currentBranch))
                            {
                                <MudSelectItem Value="@branch">@branch</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>
                    <MudItem xs="12" sm="4">
                        <MudButton Variant="Variant.Filled" 
                                  Color="Color.Error" 
                                  OnClick="DeleteBranch"
                                  Disabled="@string.IsNullOrEmpty(_branchToDelete)"
                                  FullWidth="true"
                                  StartIcon="@Icons.Material.Filled.Delete">
                            Delete
                        </MudButton>
                    </MudItem>
                </MudGrid>
            </MudCardContent>
        </MudCard>

        <!-- User Configuration -->
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">User Configuration</MudText>
                <MudText Typo="Typo.body2" Class="mb-3">
                    Configure your git identity. This information will be used for commits.
                </MudText>
                
                <MudGrid>
                    <MudItem xs="12" sm="6">
                        <MudTextField @bind-Value="_userName" 
                                     Label="Name" 
                                     Variant="Variant.Outlined"
                                     Placeholder="Your Name" />
                    </MudItem>
                    <MudItem xs="12" sm="6">
                        <MudTextField @bind-Value="_userEmail" 
                                     Label="Email" 
                                     Variant="Variant.Outlined"
                                     Placeholder="your.email@example.com" />
                    </MudItem>
                </MudGrid>
                
                <MudButton Variant="Variant.Filled" 
                          Color="Color.Primary" 
                          OnClick="SaveUserConfig"
                          Disabled="@(string.IsNullOrWhiteSpace(_userName) || string.IsNullOrWhiteSpace(_userEmail))"
                          StartIcon="@Icons.Material.Filled.Save"
                          Class="mt-3">
                    Save Configuration
                </MudButton>
            </MudCardContent>
        </MudCard>

        <!-- Remote Configuration -->
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-3">
                    <MudText Typo="Typo.h6">Remote Repositories</MudText>
                    <MudButton Variant="Variant.Outlined" 
                              Color="Color.Info" 
                              OnClick="RefreshRemotes"
                              StartIcon="@Icons.Material.Filled.Refresh"
                              Size="Size.Small"
                              Disabled="_isLoading">
                        Refresh
                    </MudButton>
                </MudStack>

                @if (_remotes.Any())
                {
                    <MudList T="string" Dense="true" Class="mb-3">
                        @foreach (var remote in _remotes)
                        {
                            <MudListItem T="string">
                                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                    <div>
                                        <MudText Typo="Typo.body1"><strong>@remote.Name</strong></MudText>
                                        <MudText Typo="Typo.body2" Style="font-size: 0.85em; color: gray;">@remote.Url</MudText>
                                    </div>
                                    <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                                  Color="Color.Error" 
                                                  Size="Size.Small"
                                                  OnClick="@(() => RemoveRemote(remote.Name))" />
                                </MudStack>
                            </MudListItem>
                        }
                    </MudList>
                }
                else
                {
                    <MudAlert Severity="Severity.Info" Class="mb-3">No remotes configured.</MudAlert>
                }

                <MudDivider Class="my-3" />

                <MudText Typo="Typo.subtitle2" Class="mb-2">Add Remote:</MudText>
                <MudGrid>
                    <MudItem xs="12" sm="4">
                        <MudTextField @bind-Value="_remoteName" 
                                     Label="Remote Name" 
                                     Variant="Variant.Outlined"
                                     Placeholder="origin" />
                    </MudItem>
                    <MudItem xs="12" sm="6">
                        <MudTextField @bind-Value="_remoteUrl" 
                                     Label="Remote URL" 
                                     Variant="Variant.Outlined"
                                     Placeholder="https://github.com/user/repo.git" />
                    </MudItem>
                    <MudItem xs="12" sm="2">
                        <MudButton Variant="Variant.Filled" 
                                  Color="Color.Success" 
                                  OnClick="AddRemote"
                                  Disabled="@(string.IsNullOrWhiteSpace(_remoteName) || string.IsNullOrWhiteSpace(_remoteUrl))"
                                  FullWidth="true"
                                  StartIcon="@Icons.Material.Filled.Add">
                            Add
                        </MudButton>
                    </MudItem>
                </MudGrid>
            </MudCardContent>
        </MudCard>

        <!-- Commit Changes -->
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">Commit Changes</MudText>
                
                @if (_fileChanges.Any())
                {
                    <MudText Typo="Typo.subtitle2" Class="mb-2">Files to Commit:</MudText>
                    <MudPaper Class="pa-3 mb-3" Outlined="true" Style="max-height: 300px; overflow-y: auto;">
                        <MudList T="string" Dense="true">
                            @foreach (var file in _fileChanges)
                            {
                                <MudListItem T="string">
                                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                        <div style="flex-grow: 1;">
                                            <MudText Typo="Typo.body2">
                                                <MudChip Size="Size.Small" Color="@GetFileStatusColor(file.Status)" Variant="Variant.Text">
                                                    @file.Status
                                                </MudChip>
                                                @file.FilePath
                                            </MudText>
                                        </div>
                                        @if (!file.IsStaged)
                                        {
                                            <MudButton Size="Size.Small" 
                                                      Variant="Variant.Text" 
                                                      OnClick="@(() => StageFile(file.FilePath))"
                                                      StartIcon="@Icons.Material.Filled.Add">
                                                Stage
                                            </MudButton>
                                        }
                                        else
                                        {
                                            <MudButton Size="Size.Small" 
                                                      Variant="Variant.Text" 
                                                      OnClick="@(() => UnstageFile(file.FilePath))"
                                                      StartIcon="@Icons.Material.Filled.Remove">
                                                Unstage
                                            </MudButton>
                                        }
                                    </MudStack>
                                </MudListItem>
                            }
                        </MudList>
                    </MudPaper>
                }
                
                <MudTextField @bind-Value="_commitMessage" 
                             Label="Commit Message" 
                             Variant="Variant.Outlined" 
                             Lines="3"
                             Class="mb-3" />
                
                <MudButton Variant="Variant.Filled" 
                          Color="Color.Primary" 
                          OnClick="CommitChanges"
                          Disabled="@(string.IsNullOrWhiteSpace(_commitMessage) || _status?.HasChanges != true)"
                          StartIcon="@Icons.Material.Filled.Save">
                    Commit All Changes
                </MudButton>
            </MudCardContent>
        </MudCard>

        <!-- Commit History -->
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-3">
                    <MudText Typo="Typo.h6">Commit History</MudText>
                    <MudButton Variant="Variant.Outlined" 
                              Color="Color.Info" 
                              OnClick="RefreshCommitHistory"
                              StartIcon="@Icons.Material.Filled.Refresh"
                              Size="Size.Small"
                              Disabled="_isLoading">
                        Refresh
                    </MudButton>
                </MudStack>

                @if (_commitHistory.Any())
                {
                    <MudPaper Class="pa-3" Outlined="true" Style="max-height: 500px; overflow-y: auto;">
                        <MudList T="string" Dense="true">
                            @foreach (var commit in _commitHistory)
                            {
                                <MudListItem T="string">
                                    <MudText Typo="Typo.body2">
                                        <MudChip Size="Size.Small" Color="Color.Primary" Variant="Variant.Text">@commit.ShortSha</MudChip>
                                        <strong>@commit.Message</strong>
                                        <br />
                                        <span style="font-size: 0.8em; color: gray;">
                                            @commit.Author - @commit.Date.ToString("yyyy-MM-dd HH:mm:ss")
                                        </span>
                                    </MudText>
                                </MudListItem>
                            }
                        </MudList>
                    </MudPaper>
                }
                else
                {
                    <MudAlert Severity="Severity.Info">No commit history available.</MudAlert>
                }
            </MudCardContent>
        </MudCard>

        <!-- Remote Operations -->
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">Remote Operations</MudText>
                
                <MudText Typo="Typo.body2" Class="mb-3">
                    Sync your changes with the remote repository.
                </MudText>

                <MudGrid>
                    <MudItem xs="12" sm="4">
                        <MudButton Variant="Variant.Filled" 
                                  Color="Color.Info" 
                                  OnClick="Fetch"
                                  StartIcon="@Icons.Material.Filled.CloudDownload"
                                  FullWidth="true"
                                  Disabled="_isLoading">
                            @if (_isFetching)
                            {
                                <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                            }
                            Fetch Changes
                        </MudButton>
                    </MudItem>
                    
                    <MudItem xs="12" sm="4">
                        <MudButton Variant="Variant.Filled" 
                                  Color="Color.Primary" 
                                  OnClick="Pull"
                                  StartIcon="@Icons.Material.Filled.GetApp"
                                  FullWidth="true"
                                  Disabled="_isLoading">
                            @if (_isPulling)
                            {
                                <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                            }
                            Pull Changes
                        </MudButton>
                    </MudItem>
                    
                    <MudItem xs="12" sm="4">
                        <MudButton Variant="Variant.Filled" 
                                  Color="Color.Secondary" 
                                  OnClick="Push"
                                  StartIcon="@Icons.Material.Filled.Publish"
                                  FullWidth="true"
                                  Disabled="_isLoading">
                            @if (_isPushing)
                            {
                                <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                            }
                            Push Changes
                        </MudButton>
                    </MudItem>
                </MudGrid>
            </MudCardContent>
        </MudCard>
    }
</MudContainer>

@code {
    private bool _isRepository;
    private string? _currentBranch;
    private List<string> _branches = new();
    private string? _selectedBranch;
    private string? _branchToDelete;
    private string _newBranchName = string.Empty;
    private string _commitMessage = string.Empty;
    private GitStatus? _status;
    private IEnumerable<GitCommitInfo> _incomingCommits = Enumerable.Empty<GitCommitInfo>();
    private IEnumerable<GitCommitInfo> _outgoingCommits = Enumerable.Empty<GitCommitInfo>();
    private IEnumerable<GitCommitInfo> _commitHistory = Enumerable.Empty<GitCommitInfo>();
    private IEnumerable<GitRemoteInfo> _remotes = Enumerable.Empty<GitRemoteInfo>();
    private IEnumerable<GitFileChange> _fileChanges = Enumerable.Empty<GitFileChange>();
    private string _userName = string.Empty;
    private string _userEmail = string.Empty;
    private string _remoteName = string.Empty;
    private string _remoteUrl = string.Empty;
    private bool _isLoading;
    private bool _isFetching;
    private bool _isPulling;
    private bool _isPushing;

    protected override async Task OnInitializedAsync()
    {
        await CheckRepository();
    }

    private async Task CheckRepository()
    {
        _isRepository = await GitService.IsRepositoryAsync();
        if (_isRepository)
        {
            await LoadRepositoryInfo();
        }
    }

    private async Task LoadRepositoryInfo()
    {
        _currentBranch = await GitService.GetCurrentBranchAsync();
        _branches = (await GitService.GetBranchesAsync()).ToList();
        _selectedBranch = _currentBranch;
        _status = await GitService.GetStatusAsync();
        _incomingCommits = await GitService.GetIncomingCommitsAsync();
        _outgoingCommits = await GitService.GetOutgoingCommitsAsync();
        _commitHistory = await GitService.GetCommitHistoryAsync(50);
        _remotes = await GitService.GetRemotesAsync();
        _fileChanges = await GitService.GetFileChangesAsync();
        
        var userConfig = await GitService.GetUserConfigAsync();
        _userName = userConfig.Name;
        _userEmail = userConfig.Email;
        
        StateHasChanged();
    }

    private async Task InitializeRepository()
    {
        try
        {
            var settings = await SettingsService.GetSettingsAsync();
            var success = await GitService.InitRepositoryAsync(settings.StoragePath);
            
            if (success)
            {
                Snackbar.Add("Git repository initialized successfully!", Severity.Success);
                await CheckRepository();
            }
            else
            {
                Snackbar.Add("Failed to initialize git repository", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error initializing repository: {ex.Message}", Severity.Error);
        }
    }

    private async Task RefreshStatus()
    {
        _isLoading = true;
        StateHasChanged();
        try
        {
            await LoadRepositoryInfo();
            Snackbar.Add("Status refreshed", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing status: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task SwitchBranch()
    {
        if (string.IsNullOrEmpty(_selectedBranch))
            return;

        try
        {
            var success = await GitService.CheckoutBranchAsync(_selectedBranch);
            
            if (success)
            {
                Snackbar.Add($"Switched to branch '{_selectedBranch}'. Navigate to other pages to see updated collections and environments.", Severity.Success);
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add($"Failed to switch to branch '{_selectedBranch}'", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error switching branch: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateBranch()
    {
        if (string.IsNullOrWhiteSpace(_newBranchName))
            return;

        try
        {
            var success = await GitService.CreateBranchAsync(_newBranchName);
            
            if (success)
            {
                Snackbar.Add($"Created and switched to branch '{_newBranchName}'", Severity.Success);
                _newBranchName = string.Empty;
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add($"Failed to create branch '{_newBranchName}'. It may already exist.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error creating branch: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteBranch()
    {
        if (string.IsNullOrEmpty(_branchToDelete))
            return;

        try
        {
            var success = await GitService.DeleteBranchAsync(_branchToDelete);
            
            if (success)
            {
                Snackbar.Add($"Branch '{_branchToDelete}' deleted successfully", Severity.Success);
                _branchToDelete = null;
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add($"Failed to delete branch '{_branchToDelete}'. Make sure you're not on that branch.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error deleting branch: {ex.Message}", Severity.Error);
        }
    }

    private async Task CommitChanges()
    {
        if (string.IsNullOrWhiteSpace(_commitMessage))
            return;

        try
        {
            var success = await GitService.CommitAllAsync(_commitMessage);
            
            if (success)
            {
                Snackbar.Add("Changes committed successfully", Severity.Success);
                _commitMessage = string.Empty;
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add("Failed to commit changes. There may be no changes to commit.", Severity.Warning);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error committing changes: {ex.Message}", Severity.Error);
        }
    }

    private async Task Fetch()
    {
        _isFetching = true;
        _isLoading = true;
        StateHasChanged();
        try
        {
            var success = await GitService.FetchAsync();
            
            if (success)
            {
                Snackbar.Add("Successfully fetched changes from remote", Severity.Success);
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add("Failed to fetch. No remote configured.", Severity.Warning);
            }
        }
        catch (LibGit2Sharp.LibGit2SharpException ex)
        {
            Snackbar.Add($"Git error: {ex.Message}", Severity.Error);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error fetching: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isFetching = false;
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task Pull()
    {
        _isPulling = true;
        _isLoading = true;
        StateHasChanged();
        try
        {
            var success = await GitService.PullAsync();
            
            if (success)
            {
                Snackbar.Add("Successfully pulled changes from remote. Navigate to other pages to see updated collections and environments.", Severity.Success);
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add("Failed to pull. No remote configured.", Severity.Warning);
            }
        }
        catch (LibGit2Sharp.LibGit2SharpException ex)
        {
            Snackbar.Add($"Git error: {ex.Message}", Severity.Error);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error pulling: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isPulling = false;
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task Push()
    {
        _isPushing = true;
        _isLoading = true;
        StateHasChanged();
        try
        {
            var success = await GitService.PushAsync();
            
            if (success)
            {
                Snackbar.Add("Successfully pushed changes to remote", Severity.Success);
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add("Failed to push. No remote configured.", Severity.Warning);
            }
        }
        catch (LibGit2Sharp.LibGit2SharpException ex)
        {
            Snackbar.Add($"Git error: {ex.Message}", Severity.Error);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error pushing: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isPushing = false;
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task SaveUserConfig()
    {
        try
        {
            var success = await GitService.SetUserConfigAsync(_userName, _userEmail);
            
            if (success)
            {
                Snackbar.Add("User configuration saved successfully", Severity.Success);
            }
            else
            {
                Snackbar.Add("Failed to save user configuration", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving user configuration: {ex.Message}", Severity.Error);
        }
    }

    private async Task AddRemote()
    {
        if (string.IsNullOrWhiteSpace(_remoteName) || string.IsNullOrWhiteSpace(_remoteUrl))
            return;

        try
        {
            var success = await GitService.AddRemoteAsync(_remoteName, _remoteUrl);
            
            if (success)
            {
                Snackbar.Add($"Remote '{_remoteName}' added successfully", Severity.Success);
                _remoteName = string.Empty;
                _remoteUrl = string.Empty;
                await RefreshRemotes();
            }
            else
            {
                Snackbar.Add($"Failed to add remote '{_remoteName}'. It may already exist.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error adding remote: {ex.Message}", Severity.Error);
        }
    }

    private async Task RemoveRemote(string name)
    {
        try
        {
            var success = await GitService.RemoveRemoteAsync(name);
            
            if (success)
            {
                Snackbar.Add($"Remote '{name}' removed successfully", Severity.Success);
                await RefreshRemotes();
            }
            else
            {
                Snackbar.Add($"Failed to remove remote '{name}'", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error removing remote: {ex.Message}", Severity.Error);
        }
    }

    private async Task RefreshRemotes()
    {
        try
        {
            _remotes = await GitService.GetRemotesAsync();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing remotes: {ex.Message}", Severity.Error);
        }
    }

    private async Task RefreshCommitHistory()
    {
        try
        {
            _commitHistory = await GitService.GetCommitHistoryAsync(50);
            Snackbar.Add("Commit history refreshed", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing commit history: {ex.Message}", Severity.Error);
        }
    }

    private async Task StageFile(string filePath)
    {
        try
        {
            var success = await GitService.StageFileAsync(filePath);
            
            if (success)
            {
                Snackbar.Add($"Staged {filePath}", Severity.Success);
                _fileChanges = await GitService.GetFileChangesAsync();
                StateHasChanged();
            }
            else
            {
                Snackbar.Add($"Failed to stage {filePath}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error staging file: {ex.Message}", Severity.Error);
        }
    }

    private async Task UnstageFile(string filePath)
    {
        try
        {
            var success = await GitService.UnstageFileAsync(filePath);
            
            if (success)
            {
                Snackbar.Add($"Unstaged {filePath}", Severity.Success);
                _fileChanges = await GitService.GetFileChangesAsync();
                StateHasChanged();
            }
            else
            {
                Snackbar.Add($"Failed to unstage {filePath}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error unstaging file: {ex.Message}", Severity.Error);
        }
    }

    private Color GetFileStatusColor(string status)
    {
        return status switch
        {
            "Added" => Color.Success,
            "Modified" => Color.Warning,
            "Deleted" => Color.Error,
            "Untracked" => Color.Info,
            "Renamed" => Color.Primary,
            _ => Color.Default
        };
    }
}
