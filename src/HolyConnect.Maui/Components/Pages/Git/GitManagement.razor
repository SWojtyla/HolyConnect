@page "/git"
@inject IGitService GitService
@inject SettingsService SettingsService
@inject ISnackbar Snackbar
@inject MudBlazor.IDialogService DialogService
@using HolyConnect.Application.Interfaces
@using LibGit2Sharp
@using HolyConnect.Maui.Components.Pages.Git.Sections

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4 mb-6">
    <MudOverlay Visible="_isLoading" DarkBackground="true" Absolute="false">
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
    </MudOverlay>
    <MudText Typo="Typo.h4" Class="mb-4">Git Management</MudText>

    @if (!_isRepository)
    {
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">Git Not Initialized</MudText>
                <MudText Typo="Typo.body2" Class="mb-3">
                    The storage path is not a git repository. Initialize git to enable version control for your collections.
                </MudText>
                <MudButton Variant="Variant.Filled" 
                          Color="Color.Primary" 
                          OnClick="InitializeRepository"
                          StartIcon="@Icons.Material.Filled.AddCircle">
                    Initialize Git Repository
                </MudButton>
            </MudCardContent>
        </MudCard>
    }
    else
    {
        <GitStatusSection 
            CurrentBranch="@_currentBranch"
            Status="@_status"
            IncomingCommits="@_incomingCommits"
            OutgoingCommits="@_outgoingCommits"
            IsLoading="@_isLoading"
            OnRefresh="RefreshStatus" />

        <GitSecretsWarningSection 
            IsSecretsTracked="@_isSecretsTracked"
            IsHistoryTracked="@_isHistoryTracked"
            IsLoading="@_isLoading"
            OnAddToGitignore="AddSecretsToGitignore" />

        <GitBranchesSection 
            CurrentBranch="@_currentBranch"
            Branches="@_branches"
            @bind-SelectedBranch="@_selectedBranch"
            @bind-NewBranchName="@_newBranchName"
            @bind-BranchToDelete="@_branchToDelete"
            OnSwitchBranch="SwitchBranch"
            OnCreateBranch="CreateBranch"
            OnDeleteBranch="DeleteBranch" />

        <GitChangesSection 
            FileChanges="@_fileChanges"
            @bind-CommitMessage="@_commitMessage"
            OnCommit="CommitChanges"
            OnStageAll="StageAllFiles"
            OnStageFile="StageFile"
            OnUnstageFile="UnstageFile"
            OnRevertFile="RevertFile"
            OnShowDiff="ShowFileDiff" />

        <GitCommitHistorySection 
            CommitHistory="@_commitHistory"
            @bind-IsExpanded="@_commitHistoryExpanded"
            IsLoading="@_isLoading"
            OnRefresh="RefreshCommitHistory" />

        <GitRemotesSection 
            IsLoading="@_isLoading"
            IsFetching="@_isFetching"
            IsPulling="@_isPulling"
            IsPushing="@_isPushing"
            OnFetch="Fetch"
            OnPull="Pull"
            OnPush="Push" />
    }
</MudContainer>

@code {
    private bool _isRepository;
    private string? _currentBranch;
    private List<string> _branches = new();
    private string? _selectedBranch;
    private string? _branchToDelete;
    private string _newBranchName = string.Empty;
    private string _commitMessage = string.Empty;
    private GitStatus? _status;
    private IEnumerable<GitCommitInfo> _incomingCommits = Enumerable.Empty<GitCommitInfo>();
    private IEnumerable<GitCommitInfo> _outgoingCommits = Enumerable.Empty<GitCommitInfo>();
    private IEnumerable<GitCommitInfo> _commitHistory = Enumerable.Empty<GitCommitInfo>();
    private IEnumerable<GitFileChange> _fileChanges = Enumerable.Empty<GitFileChange>();
    private bool _isLoading;
    private bool _isFetching;
    private bool _isPulling;
    private bool _isPushing;
    private bool _commitHistoryExpanded = false;
    private bool _isSecretsTracked = false;
    private bool _isHistoryTracked = false;

    private const int COMMIT_HISTORY_MAX_COUNT = 50;

    protected override async Task OnInitializedAsync()
    {
        await CheckRepository();
    }

    private async Task CheckRepository()
    {
        _isRepository = await GitService.IsRepositoryAsync();
        if (_isRepository)
        {
            await LoadRepositoryInfo();
        }
    }

    private async Task LoadRepositoryInfo()
    {
        _currentBranch = await GitService.GetCurrentBranchAsync();
        _branches = (await GitService.GetBranchesAsync()).ToList();
        _selectedBranch = _currentBranch;
        _status = await GitService.GetStatusAsync();
        _incomingCommits = await GitService.GetIncomingCommitsAsync();
        _outgoingCommits = await GitService.GetOutgoingCommitsAsync();
        _commitHistory = await GitService.GetCommitHistoryAsync(COMMIT_HISTORY_MAX_COUNT);
        _fileChanges = await GitService.GetFileChangesAsync();
        _isSecretsTracked = await GitService.IsSecretsTrackedAsync();
        _isHistoryTracked = await GitService.IsHistoryTrackedAsync();
        
        StateHasChanged();
    }

    private async Task InitializeRepository()
    {
        try
        {
            var settings = await SettingsService.GetSettingsAsync();
            var success = await GitService.InitRepositoryAsync(settings.StoragePath);
            
            if (success)
            {
                Snackbar.Add("Git repository initialized successfully!", Severity.Success);
                await CheckRepository();
            }
            else
            {
                Snackbar.Add("Failed to initialize git repository", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error initializing repository: {ex.Message}", Severity.Error);
        }
    }

    private async Task RefreshStatus()
    {
        _isLoading = true;
        StateHasChanged();
        try
        {
            await LoadRepositoryInfo();
            Snackbar.Add("Status refreshed", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing status: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task RefreshCommitHistory()
    {
        try
        {
            _commitHistory = await GitService.GetCommitHistoryAsync(COMMIT_HISTORY_MAX_COUNT);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing commit history: {ex.Message}", Severity.Error);
        }
    }

    private async Task SwitchBranch()
    {
        if (string.IsNullOrEmpty(_selectedBranch))
            return;

        try
        {
            var success = await GitService.CheckoutBranchAsync(_selectedBranch);
            
            if (success)
            {
                Snackbar.Add($"Switched to branch '{_selectedBranch}'. Navigate to other pages to see updated collections and environments.", Severity.Success);
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add($"Failed to switch to branch '{_selectedBranch}'", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error switching branch: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateBranch()
    {
        if (string.IsNullOrWhiteSpace(_newBranchName))
            return;

        try
        {
            var success = await GitService.CreateBranchAsync(_newBranchName);
            
            if (success)
            {
                Snackbar.Add($"Created and switched to branch '{_newBranchName}'", Severity.Success);
                _newBranchName = string.Empty;
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add($"Failed to create branch '{_newBranchName}'. It may already exist.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error creating branch: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteBranch()
    {
        if (string.IsNullOrEmpty(_branchToDelete))
            return;

        try
        {
            var success = await GitService.DeleteBranchAsync(_branchToDelete);
            
            if (success)
            {
                Snackbar.Add($"Branch '{_branchToDelete}' deleted successfully", Severity.Success);
                _branchToDelete = null;
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add($"Failed to delete branch '{_branchToDelete}'. Make sure you're not on that branch.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error deleting branch: {ex.Message}", Severity.Error);
        }
    }

    private async Task CommitChanges()
    {
        if (string.IsNullOrWhiteSpace(_commitMessage))
            return;

        try
        {
            var success = await GitService.CommitStagedAsync(_commitMessage);
            
            if (success)
            {
                Snackbar.Add("Changes committed successfully", Severity.Success);
                _commitMessage = string.Empty;
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add("Failed to commit changes. There may be no staged changes to commit.", Severity.Warning);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error committing changes: {ex.Message}", Severity.Error);
        }
    }

    private async Task Fetch()
    {
        _isFetching = true;
        _isLoading = true;
        StateHasChanged();
        try
        {
            var success = await GitService.FetchAsync();
            
            if (success)
            {
                Snackbar.Add("Successfully fetched changes from remote", Severity.Success);
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add("Failed to fetch. No remote configured.", Severity.Warning);
            }
        }
        catch (LibGit2Sharp.LibGit2SharpException ex)
        {
            Snackbar.Add($"Git error: {ex.Message}", Severity.Error);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error fetching: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isFetching = false;
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task Pull()
    {
        _isPulling = true;
        _isLoading = true;
        StateHasChanged();
        try
        {
            var success = await GitService.PullAsync();
            
            if (success)
            {
                Snackbar.Add("Successfully pulled changes from remote. Navigate to other pages to see updated collections and environments.", Severity.Success);
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add("Failed to pull. No remote configured.", Severity.Warning);
            }
        }
        catch (LibGit2Sharp.LibGit2SharpException ex)
        {
            Snackbar.Add($"Git error: {ex.Message}", Severity.Error);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error pulling: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isPulling = false;
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task Push()
    {
        _isPushing = true;
        _isLoading = true;
        StateHasChanged();
        try
        {
            var success = await GitService.PushAsync();
            
            if (success)
            {
                Snackbar.Add("Successfully pushed changes to remote", Severity.Success);
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add("Failed to push. No remote configured.", Severity.Warning);
            }
        }
        catch (LibGit2Sharp.LibGit2SharpException ex)
        {
            Snackbar.Add($"Git error: {ex.Message}", Severity.Error);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error pushing: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isPushing = false;
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task StageFile(string filePath)
    {
        try
        {
            var success = await GitService.StageFileAsync(filePath);
            
            if (success)
            {
                Snackbar.Add($"Staged {filePath}", Severity.Success);
                _fileChanges = await GitService.GetFileChangesAsync();
                StateHasChanged();
            }
            else
            {
                Snackbar.Add($"Failed to stage {filePath}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error staging file: {ex.Message}", Severity.Error);
        }
    }

    private async Task UnstageFile(string filePath)
    {
        try
        {
            var success = await GitService.UnstageFileAsync(filePath);
            
            if (success)
            {
                Snackbar.Add($"Unstaged {filePath}", Severity.Success);
                _fileChanges = await GitService.GetFileChangesAsync();
                StateHasChanged();
            }
            else
            {
                Snackbar.Add($"Failed to unstage {filePath}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error unstaging file: {ex.Message}", Severity.Error);
        }
    }

    private async Task StageAllFiles()
    {
        try
        {
            var unstagedFiles = _fileChanges.Where(f => !f.IsStaged).ToList();
            if (!unstagedFiles.Any())
                return;

            int successCount = 0;
            foreach (var file in unstagedFiles)
            {
                var success = await GitService.StageFileAsync(file.FilePath);
                if (success)
                    successCount++;
            }

            _fileChanges = await GitService.GetFileChangesAsync();
            StateHasChanged();
            
            if (successCount == unstagedFiles.Count)
            {
                Snackbar.Add($"Staged all {successCount} files", Severity.Success);
            }
            else
            {
                Snackbar.Add($"Staged {successCount} of {unstagedFiles.Count} files", Severity.Warning);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error staging files: {ex.Message}", Severity.Error);
        }
    }

    private async Task RevertFile(string filePath)
    {
        try
        {
            var success = await GitService.RevertFileAsync(filePath);
            
            if (success)
            {
                Snackbar.Add($"Reverted {filePath}", Severity.Success);
                _fileChanges = await GitService.GetFileChangesAsync();
                _status = await GitService.GetStatusAsync();
                StateHasChanged();
            }
            else
            {
                Snackbar.Add($"Failed to revert {filePath}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error reverting file: {ex.Message}", Severity.Error);
        }
    }

    private async Task AddSecretsToGitignore()
    {
        try
        {
            var success = await GitService.AddSecretsToGitignoreAsync();
            
            if (success)
            {
                Snackbar.Add("Successfully added secrets and history to .gitignore", Severity.Success);
                await LoadRepositoryInfo();
            }
            else
            {
                Snackbar.Add("Failed to add to .gitignore", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error adding to .gitignore: {ex.Message}", Severity.Error);
        }
    }

    private async Task ShowFileDiff(string filePath)
    {
        try
        {
            var parameters = new MudBlazor.DialogParameters
            {
                ["FilePath"] = filePath,
                ["IsLoading"] = true,
                ["Diff"] = null
            };

            var dialogRef = DialogService.Show<DiffViewerDialog>("File Diff", parameters, new MudBlazor.DialogOptions
            {
                MaxWidth = MudBlazor.MaxWidth.Large,
                FullWidth = true,
                CloseButton = true,
                Position = MudBlazor.DialogPosition.Center
            });

            var diff = await GitService.GetFileDiffAsync(filePath);
            // Instead of UpdateParameters, close and reopen dialog with diff
            var diffParams = new MudBlazor.DialogParameters
            {
                ["FilePath"] = filePath,
                ["IsLoading"] = false,
                ["Diff"] = diff
            };
            dialogRef.Close();
            DialogService.Show<DiffViewerDialog>("File Diff", diffParams, new MudBlazor.DialogOptions
            {
                MaxWidth = MudBlazor.MaxWidth.Large,
                FullWidth = true,
                CloseButton = true,
                Position = MudBlazor.DialogPosition.Center
            });

            if (diff == null)
            {
                Snackbar.Add($"Unable to load diff for {filePath}", Severity.Warning);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading diff: {ex.Message}", Severity.Error);
        }
    }
}
